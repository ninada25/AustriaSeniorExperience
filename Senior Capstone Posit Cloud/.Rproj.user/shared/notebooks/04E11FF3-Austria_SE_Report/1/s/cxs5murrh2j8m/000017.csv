"0","set.seed(01302024)"
"0",""
"0","library(dplyr)  # Make sure you have the dplyr package loaded"
"0",""
"0","# Divide dataset into train and test"
"0","smp_size <- floor(0.75 * nrow(countries_with_happy_imputed))"
"0","train_index <- sample(seq_len(nrow(countries_with_happy_imputed)), size = smp_size)"
"0",""
"0","train_countries <- countries_with_happy_imputed[train_index, ]"
"0","test_countries <- countries_with_happy_imputed[-train_index, ]"
"0",""
"0","cat(dim(train_countries), dim(test_countries)) # check dimensions, 102 rows in train set and 35 in test set"
"1","102"
"1"," "
"1","7"
"1"," "
"1","35"
"1"," "
"1","7"
"0","# Use rf model (10-fold CV repeated 5 times and a basic RF model)"
"0","cv_specs <- trainControl(method = ""repeatedcv"", number = 10, repeats = 5, verboseIter = FALSE) # CV specifications"
"0",""
"0","model_rf_countries <- train(x = dplyr::select(train_countries, -Happiness_score), "
"0","                            y = train_countries$Happiness_score, "
"0","                            method = ""rf"", "
"0","                            trControl = cv_specs,"
"0","                            metric = ""RMSE"")"
"0",""
"0","model_rf_countries # optimal mtry = 8"
"1","Random Forest"
"1"," "
"1","

"
"1","102"
"1",""
"1"," samples"
"1","
"
"1","  6"
"1",""
"1"," predictor"
"1",""
"1","
"
"1","
"
"1","No pre-processing
"
"1","Resampling:"
"1"," "
"1","Cross-Validated (10 fold, repeated 5 times)"
"1"," "
"1","
"
"1","Summary of sample sizes:"
"1"," "
"1","93, 91, 92, 92, 92, 92, ..."
"1"," "
"1","
"
"1","Resampling results"
"1"," across tuning parameters"
"1",":

"
"1",""
"1","  mtry"
"1","  RMSE "
"1","  Rsquared"
"1","  MAE  "
"1","
"
"1","  2   "
"1","  0.556"
"1","  0.793   "
"1","  0.447"
"1","
"
"1","  4   "
"1","  0.560"
"1","  0.785   "
"1","  0.450"
"1","
"
"1","  6   "
"1","  0.570"
"1","  0.776   "
"1","  0.459"
"1","
"
"1","
"
"1","RMSE was used to select the optimal model using the smallest value.
"
"1","The final value used for the model was mtry = 2."
"1","
"
"0","# Apply the predict function of this model on test set and get RMSE"
"0","countries_rf_preds <- predict(model_rf_countries, newdata = dplyr::select(test_countries, -Happiness_score))"
"0","# mean(test_countries$Happiness_score == countries_rf_preds) ## ??????"
"0",""
"0","# Now we have our model! Use LIME to create an explainer object."
"0","explainer <- lime(dplyr::select(train_countries, -Happiness_score), model_rf_countries) # model_rf is the model whose output should be explained"
"0",""
"0","# Explain predictions on a subset of the test set"
"0","explanation <- test_countries %>% "
"0","  dplyr::select(-Happiness_score) %>%  # Remove the Happiness_score column"
"0"," # slice(1:10) %>%"
"0","  lime::explain(explainer = explainer, "
"0","                n_labels = 1, "
"0","                n_features = 6, "
"0","                n_permutations = 5000, "
"0","                kernel_width = 0.5)  "
"0",""
"0","# Visualize this explanation"
"0","# plot_features(explanation, ncol = 4)"
"0",""
"0","# Grouping by feature, taking the sum of the abs value of feature weights, and arranging in a df sorted in order of descending feature weight: "
"0","total_feature_weights_countries <- explanation %>% "
"0","  group_by(feature) %>% "
"0","  summarize(total_feature_weight = sum(abs(feature_weight)),"
"0","            total_feature_weight_as_perc = (total_feature_weight/(sum(abs(explanation$feature_weight)))* 100)) %>%"
"0","  arrange(desc(total_feature_weight)) "
"0",""
"0","# Round the dataframe"
"0","round_df <- function(x, digits) {"
"0","  numeric_columns <- sapply(x, class) == 'numeric'"
"0","  x[numeric_columns] <-  round(x[numeric_columns], digits)"
"0","  x"
"0","}"
"0",""
"0","total_feature_weights_countries <- round_df(total_feature_weights_countries, 2)"
"0",""
"0","# Save the results"
"0","save(total_feature_weights_countries, file = ""lime_countries.Rdata"")"
"0",""
"0","# Load the results"
"0","load(""lime_countries.Rdata"")"
"0",""
"0","# Create a new dataframe with only 'feature' and 'total_feature_weight_as_perc' columns"
"0","total_feature_weights_as_perc_countries <- total_feature_weights_countries[, c(""feature"", ""total_feature_weight_as_perc"")]"
"0",""
"0","# This dataframe contains feature names and their corresponding weights as percentages"
"0","total_feature_weights_as_perc_countries"
